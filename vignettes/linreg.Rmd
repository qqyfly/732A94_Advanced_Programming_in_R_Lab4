---
title: "linreg"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{linreg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
library(ggplot2)
library(MASS)
library(gridExtra)
library(png)
#libraries used in this code.
# we name the 
Linreg <- function(formula, data, qr = FALSE) {
  linreg <- list(coefficients = NULL,
                 residuals = NULL,
                 fitted_values = NULL,
                 formula = formula,
                 data = data,
                 qr = qr,
                 data_name = substitute(data),
                 X_name = NULL)
  class(linreg) <- "Linreg"
  return(linreg)
}

lm_new <- function(obj) {
  formula<- obj$formula
  data <- obj$data
  
  vars <- all.vars(formula)
  
  # get the number of variables
  n <- length(all.vars(formula))
  
  y_formula <- paste("~",vars[1],"-1")
  y_name <- vars[1]
  y_data <- model.matrix(as.formula(y_formula),data)
  
  # remove XXX in the following model.matrix function call 
  X_formula <- update(formula,~ . - 1)
  
  # Create the design matrix X
  X_name <- vars[2:n]
  obj$X_name <- X_name
  X_data <- model.matrix(X_formula, data)
  
  # transpose of X_data
  X_data_t = t(as.matrix(X_data))
  
  # calc coef here
  # use ginv to calc Generalized Inverse of a Matrix instead of solve
  # because solve will generate singular problem
  
  coefficients <- crossprod(tcrossprod(
    ginv(
      crossprod(x = as.matrix(X_data_t))
    ),X_data_t),y_data)
  
  obj$coefficients <- coefficients
  
  
  # calc fitted values 
  fitted_values <- crossprod(X_data_t,coefficients)
  obj$fitted_values <- fitted_values 
  
  # calc residuals
  residuals <- y_data - obj$fitted_values
  obj$residuals <- residuals
  
  # calc degrees of freedom
  df <- nrow(data) - n
  
  # calc residual variance
  fitted_values_t <- t(as.matrix(fitted_values))
  residual_var <- crossprod(x = as.matrix(fitted_values_t)) / df
  
  # calc variance of the regression coefficients
  var_b_hat <- crossprod(residual_var,ginv(
    crossprod(x = as.matrix(X_data_t))
  ))
  return(obj)
}

print <- function(obj) {
  cat("Call:\n",
      "lim(formula = ",Reduce(paste, deparse(obj$formula)),",data =",obj$data_name,"\n\n",
      "Coefficients:\n",
      obj$X_name,"\n",
      obj$coefficients
      )
}

get_png <- function(filename) {
  grid::rasterGrob(png::readPNG(filename), interpolate = TRUE)
}

plot <- function(obj) {
  FV <- as.data.frame(obj$fitted_values)
  RS1 <- as.data.frame(obj$residuals)
  K <- data.frame(FV,RS1)
  p1 <- ggplot(data = K,mapping = aes_string(x = names(K)[1], y = names(K)[2])) + 
         geom_point() +
         theme(plot.title = element_text(hjust = 0.5)) + 
         labs(
            title = "Residuals vs Fitted",
            x = "Fitted values \n lm(Petal.Length ~ Species)",
            y = "Residuals"
          ) 
   
  # calc the mean of residuals-> miu
  miu <- mean(RS1[[names(RS1)[1]]]) 
  
  sigma <- sqrt(sum((RS1 - miu) ^ 2) / nrow(RS1))
  
  RS2 <- abs((RS1 - miu) / sigma)
  K <- data.frame(FV,RS2)
  
  p2 <- ggplot(data = K,mapping = aes_string(x = names(K)[1], y = names(K)[2])) + 
    geom_point() +
    theme(plot.title = element_text(hjust = 0.5)) + 
    labs(
      title = "Scaleâˆ’Location",
      x = "Fitted values \n lm(Petal.Length ~ Species)",
      y = "$\\sqrt(Standard Residuals)$"
    ) 
  
 
  grid.arrange(p1, p2, ncol = 1)
  

  
}

resid <- function(obj){
  return(obj$residuals)
}

pred <- function(obj){
  return(obj$fitted_values)
}

coef <- function(obj){
  return(obj$coefficients)
}

summary <- function(obj){
  
}

```{r setup}
library(lab04)
```
